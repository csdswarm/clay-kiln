'use strict';

const parseHttpDate = require('parsehttpdate'),
  axios = require('axios'),
  { removeEtag, wrapInTryCatch } = require('../middleware-utils'),
  redis = require('../../server/redis'),
  url = require('url'),
  parseString = require('xml2js').parseStringPromise,
  _get = require('lodash/get'),
  _isEqual = require('lodash/isEqual'),
  /**
   * Parsing the values from Redis key
   * this will return and object with two properties
   * lastModified: a date in string
   * feed: MSN Feed data as XML
   *
   * @param {string} redisData MSN Feed Data
   * @return {Object}
   */
  parseOldModifiedFeed = redisData => JSON.parse(redisData),

  /**
   * Getting pubDates and links from the XML
   * This will return an array with 2 properties
   * [
   *  {
   *    link: http://radio.com/music/pop/demi-lovato-hints-at-new-music-in-tease-y-instagram-post,
   *    pubDate: Thu, 28 May 2020 18:05:49 +0000
   *  },
   * ...
   * ]
   *
   * @param {string} feed XML MSN feed
   * @return {Array}
   */
  getXMLItems = async feed => {
    const json =  await parseString(feed, { explicitArray : false }),
      items = _get(json.rss.channel, 'item');
      
    if (!items) {
      return;
    }
    return items.map(item => ({
      link: item.link,
      pubDate: item.pubDate
    }));
  },
  /**
   * Compares two arrays and determines if they are the same or not
   * This will return true or false
   *
   * @param {Array} oldFeed
   * @param {Array} newFeed
   * @return {bool}
   */

  areEqual = (oldFeed, newFeed) => _isEqual(oldFeed, newFeed),
  {
    CLAY_SITE_PROTOCOL: protocol,
    CLAY_SITE_HOST: host
  } = process.env;

/**
 * Exposes an endpoint '/rdc/msn-feed.rss'
 *
 * 'rdc' here is a namespace convention I'm going to try out for fastly purposes
 *   since we share our domain with other teams.
 *
 * this endpoint is necessary because the default rss feed sets the ETag header
 *   to a unique value every time.  Msn penalizes for that so providing our own
 *   endpoint allows us control over the headers.  Alternatively we could have
 *   intercepted the component instance's route and done the same thing, but
 *   I prefer keeping that component route untouched and use a separate one for
 *   this purpose.
 *
 * @param {object} router
 */
module.exports = router => {
  router.get('/rdc/msn-feed.rss', wrapInTryCatch(async (req, res) => {
    // the autogenerated ETag header was changing even when our content wasn't.
    // instead of creating our own ETag header I thought it'd be easier to
    //   implement last-modified
    removeEtag(res);

    const endpoint = `${protocol}://${host}/_components/feeds/instances/msn.msn`;

    let query = url.parse(req.url).query,
      lastModifiedStr,
      oldFeedData;

    query = query
      ? `?${query}`
      : '';
    
    const ifModifiedSinceStr = req.get('if-modified-since'),
      [oldFeedResult, newFeedResult] = await Promise.all([
        redis.get(`msn-feed:${query}`),
        axios.get(endpoint + query)
      ]),
      newFeedData = await getXMLItems(newFeedResult.data);

    if (oldFeedResult) {
      const { lastModified, feed } = parseOldModifiedFeed(oldFeedResult);
      
      oldFeedData = JSON.parse(feed);
      lastModifiedStr = lastModified;
    }
    
    if (!areEqual(oldFeedData, newFeedData)) {
      lastModifiedStr = new Date().toUTCString();
      redis.set(`msn-feed:${query}`, JSON.stringify({
        lastModified: lastModifiedStr,
        feed: JSON.stringify(newFeedData)
      }));
    }

    res.set('Last-Modified', lastModifiedStr);

    if (ifModifiedSinceStr) {
      // apparently the http spec defines two obsolete date formats which
      //   parseHttpDate doesn't support:
      //
      //   https://www.npmjs.com/package/parsehttpdate#other-formats
      //
      //   If MSN sends us dates in those formats then we'll have to find
      //   another solution
      const ifModifiedSinceDate = parseHttpDate(ifModifiedSinceStr),
        lastModifiedDate = new Date(lastModifiedStr);

      if (lastModifiedDate <= ifModifiedSinceDate) {
        res.status(304).end();
        return;
      }
    }

    res.send(newFeedResult.data);
  }));
};
