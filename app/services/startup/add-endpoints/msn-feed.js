'use strict';

const parseHttpDate = require('parsehttpdate'),
  axios = require('axios'),
  { removeEtag, wrapInTryCatch } = require('../middleware-utils'),
  redis = require('../../server/redis'),
  url = require('url'),
  xmlParser = require('xml2json'),
  _isEmpty = require('lodash/isEmpty'),
  _get = require('lodash/get'),
  _isEqual = require('lodash/isEqual'),
  /**
     * Parsing the values from Redis key
     * this will return and object with two properties
     * lastModified: a date in string
	   * feed: MSN Feed data as XML
	   *
	   * @param {string} redisData MSN Feed Data
	   * @return {Object}
	   */
  parseOldModifiedFeed = redisData => JSON.parse(redisData),

  /**
   * Getting pubDates and links from the XML
   * This will return an array with 2 properties
   * [
   *  {
   *    link: http://radio.com/music/pop/demi-lovato-hints-at-new-music-in-tease-y-instagram-post,
   *    pubDate: Thu, 28 May 2020 18:05:49 +0000
   *  },
   * ...
   * ]
   *
   * @param {string} feed XML MSN feed
   * @return {Array}
   */
  getXMLItems = feed => {
    const json = xmlParser.toJson(feed, {
        object: true,
        sanitize: true,
        trim: true,
        arrayNotation: false
      }),
      items = _get(json.rss.channel, 'item');

    return items.map(item => ({
      link: item.link,
      pubDate: item.pubDate
    }));
  },
  /**
   * Compares two arrays and determines if they are the same or not
   * This will return true or false
   *
   * @param {Array} oldFeed
   * @param {Array} newFeed
   * @return {bool}
   */

  areEqual = (oldFeed, newFeed) => _isEqual(oldFeed, newFeed),
  {
    CLAY_SITE_PROTOCOL: protocol,
    CLAY_SITE_HOST: host
  } = process.env;

/**
 * Exposes an endpoint '/rdc/msn-feed.rss'
 *
 * 'rdc' here is a namespace convention I'm going to try out for fastly purposes
 *   since we share our domain with other teams.
 *
 * this endpoint is necessary because the default rss feed sets the ETag header
 *   to a unique value every time.  Msn penalizes for that so providing our own
 *   endpoint allows us control over the headers.  Alternatively we could have
 *   intercepted the component instance's route and done the same thing, but
 *   I prefer keeping that component route untouched and use a separate one for
 *   this purpose.
 *
 * @param {object} router
 */
module.exports = router => {
  router.get('/rdc/msn-feed.rss', wrapInTryCatch(async (req, res) => {
    // the autogenerated ETag header was changing even when our content wasn't.
    // instead of creating our own ETag header I thought it'd be easier to
    //   implement last-modified
    removeEtag(res);
    const query = _get(url.parse(req.url), 'query'),
      ifModifiedSinceStr = req.get('if-modified-since'),
      lastModifiedDate = new Date(),
      endpoint = `${protocol}://${host}/_components/feeds/instances/msn.msn`;

    if (!query) {
      if (ifModifiedSinceStr) {
        // apparently the http spec defines two obsolete date formats which
        //   parseHttpDate doesn't support:
        //
        //   https://www.npmjs.com/package/parsehttpdate#other-formats
        //
        //   If MSN sends us dates in those formats then we'll have to find
        //   another solution
        const ifModifiedSinceDate = parseHttpDate(ifModifiedSinceStr);
    
        if (lastModifiedDate <= ifModifiedSinceDate) {
          res.status(304).end();
          return;
        }
      }
    
      const resp = await axios.get(endpoint);
    
      return res.send(resp.data);
    }
    // This lane is when the endpoint request comes with query param to filter by station
    let lastModifiedStr,
      oldFeedData;
    // Get the old feed result from Redis
    const oldFeedResult = await redis.get(`msn-feed:${query}`);

    if (!_isEmpty(oldFeedResult)) {
      // the data from redis needs to be parsed
      const { lastModified, feed } = parseOldModifiedFeed(oldFeedResult);

      // The list and pubDate data need to be extracted from the XML
      oldFeedData = getXMLItems(feed);
      // Assign lastModified date from Redis to a variable
      lastModifiedStr = lastModified;
    }
    // Get the MSN feed data filter by station
    const newFeedResult = await axios.get(`${endpoint}?${query}`),
      // The list and pubDate data need to be extracted from the XML
      newFeedData = getXMLItems(newFeedResult.data);

    // Check if the lastModified date was assigned or if the newFeedData and the oldFeedData are equal
    // If they're different then a new Redis key is assigned
    // Otherwise the request will return a 304 message
    if (!lastModifiedStr || !areEqual(oldFeedData, newFeedData)) {
      redis.set(`msn-feed:${query}`, JSON.stringify({
        lastModified: new Date().toUTCString(),
        feed: newFeedResult.data
      }));
    } else {
      res.status(304).end();
      return;
    }

    if (ifModifiedSinceStr) {
      // apparently the http spec defines two obsolete date formats which
      //   parseHttpDate doesn't support:
      //
      //   https://www.npmjs.com/package/parsehttpdate#other-formats
      //
      //   If MSN sends us dates in those formats then we'll have to find
      //   another solution
      const ifModifiedSinceDate = parseHttpDate(ifModifiedSinceStr);

      if (lastModifiedDate <= ifModifiedSinceDate) {
        res.status(304).end();
        return;
      }
    }

    res.send(newFeedResult.data);
  }));
};
